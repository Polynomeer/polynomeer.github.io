# 스프링 핵심 원리 - 기본편

## 1. 객체 지향 설계와 스프링

## 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생

### 스프링 탄생 배경

EJB로 영업을 잘 해서 보급이 많이 되었다. 물론 장점도 나름대로 있었다. 분산기술 지원, 트랜잭션의 관리 등이 용이했다. 이론적인 부분에서의 지원이 되었으며, 심지어 ORM까지 가능하도록 해서 SQL쿼리를 작성하지 않아도 되는 기술을 당시에 제공했다.

하지만 EJB 지옥이라고 불릴만큼 EJB는 관리 및 개발이 너무 어려웠다. 컨테이너 하나를 띄우는데에도 한참이 걸리는 치명적인 문제가 있었다. EJB 의존적인 코드는 매우 지저분하다는 말도 많았다. 그래서 POJO라는 말이 나오면서 옛날의 자바로 돌아가자는 운동 또한 일어났다. 그만큼 EJB의 기술 수준은 매우 낮았다.

그래서 등장한 것이 Hibernate와 Spring이다. EJB의 개발에 참여했던 로드 존슨은 그 자체를 비판하면서 Spring을 제안하였다. 그리고 다른 진영에서는 게빈 킹이 오픈소스로 Hibernate를 제안하였다. 여기에서 더욱 발전하여 현재는 JPA 인터페이스를 '구현'하는 Hibernate, EclipseLink 및 기타 JPA 구현체가 있다.

### 스프링의 탄생

로드 존슨은 EJB의 문제점을 지적한다. J2EE Design and Development라는 책에서는 현대의 스프링에 대한 개념이 모두 나왔다. 책 출간 직후 유겐 휠러, 얀 카로프가 오픈소스 프로젝트를 제안하고 현재의 스프링이 탄생하게 되었다. J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는 뜻으로 Spring이라는 이름이 붙게 되었다.

### 스프링 역사

- 2003년 스프링 프레임워크 1.0 출시 - XML
- ...

옛날에는 '스프링은 설정이 반이다'라는 말이 있을 정도로 설정에 시간을 많이 투자해야 했다. 하지만 현재는 `스프링 부트`를 사용함으로써 그 설정에 대한 시간이 거의 들지 않게 되었다.

## 스프링이란?

스프링 개발에서 필수 사항은 `스프링 프레임워크` 와 `스프링 부트`이다. 그리고 기타 많은 기술들이 있다. 스프링 기술은 spring.io의 project overview에서 확인할 수 있다.

- 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술 : 스프링 MVC, 스프링 WebFux
- 데이터 접근 기술 :

### 스프링 부트

스프링을 편리하게 사용할 수 있도록 지원하는 프레임 워크이다. 최근에는 기본으로 사용한다. 이전에는 톰캣 웹서버를 설치하고 데이터베이스 등 설정을 모두 한땀한땀 해야했었다. 하지만 현재는 starter를 통해서 종속성을 한꺼번에 당겨온다. 또한 과거에는 스프링 버전에 따른 궁합을 맞추어서 버전을 일일이 확인해서 당겨와야 했다. 하지만 현재는 이미 궁합이 맞는 외부 라이브러리의 버전을 알아서 찾아온다.

스프링 부트는 스프링과 별도의 프로젝트가 아니다. 스프링 부트는 기본적으로 스프링 프레임워크를 활용하는 측면에서 도와주는 역할을 주로 담당한다.

### 스프링 단어?

스프링이라는 단어는 문맥에 따라 다르게 사용된다. 스프링 DI 컨테이너 기술을 말하기도 하고, 스프링 프레임워크 자체를 말하기도 한다. 또는 스프링 부트를 포함한 스프링 생태계 전부를 의미하기도 한다.

### 핵심 개념

- 이 기술을 왜 만들었는가?
- 이 기술의 핵심 컨셉은?

스프링을 보면 매우 복잡해 보인다. 하지만 우리는 이것이 왜 필요한지 잘 알지 못한다. 따라서 기술을 제대로 이해하려면 '이 기술을 왜 만들었는가?' 그 **핵심 컨셉**을 익히는 것이 매우 중요하다.

스프링은 자바 언어 기반의 프레임워크이다. 자바 언어의 가장 큰 특징은 **객체 지향 언어**라는 것인데, 스프링은 객체 지향 언어가 가진 강력한 특징을 살려낼 수 있게된다. 스프링은 **좋은 객체 지향** 애플리케이션을 개발할 수 있게 도와주는 프레임워크이다.

그렇다면 좋은 객체 지향이라는 것은 뭘까?

## 좋은 객체 지향 프로그래밍이란?

### 다형성

[운전자와 자동차]

운전자와 자동차는 각각의 역할이 있다. 자동차 역할을 구현하는 K3, 아반떼, 테슬라가 있다고 하자. 운전자는 K3를 타다가 아반뗴를 탈 수 있다. 즉, 운전자는 **자동차의 변경과 관계없이 운전이 가능하다.** 이는 각 자동차가 자동차의 역할을 다 따르면서 구현을 하였기 때문이다. 운전자는 자동차의 역할만 알면 되는 것이다.

이렇게 클라이언트(운전자)는 자동차의 내부구조를 굳이 몰라도 운전이 가능하다. 새로운 자동차를 아무리 출시해도 자동차 역할이 동일하다면 운전자가 새로운 무언가를 배울 필요가 없다.

[공연 무대(로미오와 줄리엣)]

로미오 역할을 장동건이 하든, 원빈이 하든 문제가 되지 않는다. 마찬가지로 줄리엣 역할을 송혜교가 하든, 김태희가 하든 문제가 되지 않는다. 이것을 바로 대체가 가능하며 변경이 용이하다고 한다.

### 역할과 구현을 분리

역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다. 이러한 컨셉의 장점은 클라이언트는 대상의 역할(인터페이스)만 알면 되며, 구현 대상의 내부 구조를 몰라도 된다는 것이다.

- 자바 언어의 다형성을 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할

### 객체의 협력이라는 관계부터 생각

혼자있는 객체는 없다. 클라이언트: 요청, 서버: 응답 이라고 보면된다. 이렇듯 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.

클라이언트 -> 서버 -> 또 다른 서버

### 자바 언어의 다형성

오버라이딩을 떠올려보면 다형성으로 인터페이스를 구현한 객체를 실행시간에 변경하여 사용이 가능하다.

### 다형성의 본질

인터페이스를 구현한 객체 인스턴스를 **실행 시점**에 유연하게 변경할 수 있다.

### 역할과 구현을 분리

한계점 -> 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다. 따라서 인터페이스의 변화가 거의 없는 방향으로 설계하는 것이 매우 중요하다. 만약 변화가 있더라도 인터페이스 구조가 크게 흔들리지 않도록 하는 것이 좋다. 인터페이스의 안정적인 설계가 중요하다.

### 스프링과 객체 지향

스프링은 다형성을 극대화해서 이용할 수 있게 도와준다. 스프링에서 이야기하는 IoC, DI는 다형성을 활용해서 역할과 구현을 편리하게 할 수 있도록 도와준다.

## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

### SRP 단일 책임 원칙(Single Responsibility Principle)

한 클래스는 하나의 책임만 가져야 한다. 그런데 하나의 책임이라는 것은 모호하다. 클 수도 있고, 작을 수도 있다. 이는 문맥과 상황에 따라 다르다. **중요한 기준은 변경**이다. 변경이 있을 때 파급효과가 작으면 단일 책임 원칙을 잘 따른 것이라고 볼 수 있다. 그 기준에 맞도록 적절하게 조절해야한다.

### OCP 개방-폐쇄 원칙(Open/Closed Principle) - 중요

소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다.

이전의 예에서 자동차가 기름차를 전기차로 바꾼다해도 역할이 바뀌진 않는다. 공연의 예에서는 구현과 역할을 분리해놓으면 구현은 정 안되면 무명배우가 해도 되는 것이다.

이때 다형성을 활용해보면 된다.

이 원칙의 문제점은 다음과 같다.

```java
public class MemberService {
//		private MemberRepository memberRepository = new MemoryMemberRepository();
  	private MemberRepository memberRepository = new JdbcMemberRepository();
}
```

위의 코드를 보면 OCP가 깨지는 경우가 발생한다. 이를 지키기 위해서는 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다. 바로 이것을 스프링 컨테이너가 자동으로 해주게 된다.

### LSP 리스코프 치환 원칙(Liskov Substitution Principle)

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

액셀은 앞으로 가라는 기능이다. 하지만 이를 뒤로가게 구현하면, 분명히 실행은 된다. 하지만 LSP를 위반하는 것이 된다. 느리더라도 앞으로만 간다면 LSP를 위반하지 않게 된다.

### ISP 인터페이스 분리 원칙(Interface Segregartion Principle)

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. 자동차 인터페이스 하나는 너무 크기 떄문에, 운전 인터페이스와 정비 인터페이스를 분리 해볼 수 있다. 이에 대응하도록 사용자 클라이언트는 운전자 클라이언트와 정비사 클라이언트로 분리할 수 있다. 이런 경우에 정비 인터페이스 자체가 변하더라도 정비 클라이언트에는 영향을 주지만, 운전자 클라이언트에는 영향을 주지 않는다. 이렇게 인터페이스가 명확해지고, 대체 가능성이 높아지게 된다.

### DIP 의존관계 역전 원칙(Dependency Inversion Principle) - 중요

프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다" 의존성 주입은 이 원칙을 따르는 방법 중 하나이다. 다시 말해, 클라이언트 코드가 구현클래스를 바라보지말고 인터페이스만 바라봐야한다는 것이다.

운전자는 자동차 역할에 대해서만 알아야지 K3에 대해서 구체적으로 알면 안된다는 것이다. 또 장동건이 김태희만 보고 연습해서 다른 배우와 연기가 불가능하면 안된다. 즉, 얼마든지 대체가능하도록 역할(Role)에만 의존해야지 구현체에 의존하면 안된다.

## 객체 지향 설계와 스프링

스프링은 다음 기술로 다형성 + OCP, DIP

