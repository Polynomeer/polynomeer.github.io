# 2021-02-15-TIL

자바의  스펙을 구현한 것이 JVM이다.

자바는 처음에 가전제품용으로 실패했지만, 웹이 발전하면서 자바 애플릿으로 유명해졌다.

자바파일을 컴파일하면 자바 바이트코드가 포함된 클래스파일이 생성된다.

클래스 로더가 클래스파일을 메모리에 로딩한다.

Native method library로 C로 작성된 라이브러리들을 불러올 수 있다.

Inner class와 외부 2개의 클래스 생성

클래스파일을 클래스 로더가 메모리에 로드하고, 그 로드된 데이터를 읽으면서 엑시큐션 엔진이 실행한다.

동적으로 로딩 가능한데, C언어의 dynamic linking과 유사

FQCN 은 클래스패스

힙에는 객체가 들어가고 스택에는 지역변수와 메서드 상태가 저장된다.

PC는 CPU의 프로그램 카운터같은걸 메모리에 만들어놓은 건가요?

클래스 이름 필드 관계 등 정보가 메서드 에어리어에 들어간다.

스태틱변수는 링커에의해서 링킹과정에 초기화된다. static int age = 25; 라면 0으로 일단 초기화 된다. init단계에서 25가 저장된다.

생성자는 힙에 객체가 할당될때 생성된다. 스태틱은 클래스로더가 

클래스를 동적으로 로딩해주기 때문에 Hell의 static블록은 static이라도 로딩하지 않는다. 필요할 때 로딩한다.

메서드 영역에 다 넣는데 메서드 영역이라 하는지 모르지만, 이상한건 다 메서드영역에 들어간다.

new로 만드는 것들 enum은 힙영역에 들어감

스레드는 개별적인 스택영역을 가지는데 이를통해서 개별 메서드를 실행할수있다. 그리고 이를 문맥교환하기위햇 PC가 스레드별 PC를 가진다.

매번 인터프리터가 바이트코드를 번역하지 않아도 되어서 JIT덕분에 성능이 엄청 좋아졌다. 바이트코드를 실행시간에 기계어로 번역해준다.

바이트코드도 메서드영역에 들어있따.

스태틱 변수는 클래스로더가 로딩할때 메서드영역에 저장된다.

인스턴스변수는 힙에 저장된다. new를 만났을때

리터럴은 메서드영역에

자바의 참조 타입이 왜 없는가? 



Q) 테스트 코드에서 board.initialize()에 접근하려면 initialize()가 public이거나 package-private이어야 한다. private인 상태로 테스트 코드에서 실행할 방법은 없는건가? 테스트 코드 때문에 접근제한자가 달라진다면 테스트 코드가 메인 코드에 영향을 끼치는 문제가 발생하는 것이 아닌가?

### 미션3: 체스판 초기화

안녕하세요! '미션3: 체스판 초기화'를 구현하고 주어진 테스트 코드를 실행 해보았습니다. 구현 내용은 아래와 같습니다.

### 구현 내용
#### 1. main

_pieces_

- Piece.java
  - char 타입의 representation필드를 추가하여, 상속받은 체스말들이 모두 표기될 문자를 필드로 갖도록 했습니다.
  - representation에 대한 getter도 추가했습니다.

- Pawn.java
  - 상수 필드로 검정색 폰, 흰색 폰의 표기문자를 갖습니다.
  - 생성자 오버로딩을 통해 기본적으로는 흰색의 값을 가지도록 했습니다.
  - getRepresentation()은 부모 생성자(Piece의 생성자)를 호출해서 representation필드를 읽어옵니다.

_chess_

- Board.java

  - 기존의 board 리스트를 `whitePieces`, `blackPieces`로 각각 나누어서 저장하도록 했습니다.
  - 기존의 add 메서드를 색깔별로 `addWhite`, `addBlack`으로 나누었습니다.
  - find메서드도 `findWhite`, `findBlack`으로 나누었습니다.
  - `initialize()` : `BOARD_SIZE`라는 상수를 필드에 선언하여, 그 크기만큼 체스말들을 리스트에 추가합니다.
  - `getPiecesResult(List<Piece) pieces)` : 체스말 리스트를 매개변수로 받아서 해당 말의 표기문자를 문자열에 하나씩 붙여서 리턴합니다.
  - `getBlackPawnsResult()`와 `getWhitePawnsResult()`는 `getPiecesResult()`를 호출하는데, 색깔별 체스말의 리스트를 넘겨줍니다. 추후에는 `getBlackResult()`, `getWhiteResult()`로 변경하여 전체 결과를 가져올 수 있도록 해야합니다.
  - `print()` : 폰 이외에 빈칸을 `.`으로 모두 채우고 폰의 위치에 `getWhitePawnsResult()`, `getBlackPawnsResult()`로 가져온 결과 문자열을 이어붙여서 전체 보드를 출력합니다.

  

#### 2. test

_chess_

- BoardTest.java
  - `initialize()` : `Board::initialize()`호출 후 각 색깔의 폰 리스트가 적절히 초기화 되었는지 테스트합니다.
  - 이전에 작성한 메서드들은 우선은 if문으로 분기하여 실행할 수 있도록 변경했습니다.
  - `assertEquals()` 보다 `assertThat()`이 장점이 많다는 것을 학습하여 `assertThat()`으로 변경했습니다.
